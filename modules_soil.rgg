import static parameters.*;
import static environment.*;
import static modules_base.*;
import static modules_light.*;

import de.grogra.ray.physics.Spectrum;
import de.grogra.ray.physics.Spectrum3d;

// soil profile associated to an individual plant
module SoilLayer
{
	int    row;
	int	   strip;
	int    rank;
	double upper;
	double bottom;
	double LL;
	double DUL;
	double SAT;
	double KSAT;
	double BDEN;
	double SLOC;
	double Thickness;
	double PlantDist;
	double RowDist;
	double Depth;
	double SWC;
	
	void initialConditions(){
	
		SWC = DUL;
	}
	
	
	void infil(){
	}
	
	void satflow(){
	}
	
	void upflow(){
	}
	

	// initiation of a soil layer
	void initiate(int nLayer, int TileRow, int TileStrip)
	{
		rank 	= nLayer;
		row  	= TileRow;
		strip 	= TileStrip;
		Depth 	= Layer_Depth[nLayer-1];
		LL 		= Layer_LL[nLayer-1];
		DUL 	= Layer_DUL[nLayer-1];
		SAT		= Layer_SAT[nLayer-1];
		KSAT	= Layer_KSAT[nLayer-1];
		BDEN	= Layer_BDEN[nLayer-1];
		SLOC	= Layer_SLOC[nLayer-1];
		
		Thickness = (nLayer == 1 ? Layer_Depth[nLayer-1]:(Layer_Depth[nLayer-1] - Layer_Depth[nLayer-2]));
		upper = Depth - Thickness;
		bottom = Depth;
		
		PlantDist = 0.25;
		RowDist = 1.4;
		
		if(nLayer == 1) {Depth = Depth + 0.001;}
		
		
	}
} 
==> 
Translate(0,0,-Depth) Box(Thickness,PlantDist,RowDist).(setColor(0.51,0.33,0.16))
;

module SoilProfile() extends Null{
	
	int		row;
	int		strip;
	int		cn;
	int		nLayers;
	int		tdlno;
	double	swcon;
	double 	runoff;
	double	watavl;
	double  winf;		//Water available for infiltration - rainfall minus runoff plus  net irrigation (mm / d)
	double  pinf;
	double drain;
	double infilt;
	double flood;
	double excs; // check if here is the right place for it
	boolean puddled;
	boolean bunded;
	
	boolean mulchEffect;
	double mulch;
	
	// Run-off calculations
	void runoff(){
		
		//cn = curve number - measure of runoff potential based on soil type and current soil water content. 
		//watavl = rain + irrigation;
		
		double swabi;			// A soil water abstraction index, a unitless indicator of the soil water condition at the time of a rainfall event.  This affects the intercept of the runoff axis when runoff starts to occur--later when drier and sooner when wetter.
		double iabs;			// Initial abstraction ratio, modified for surface mulch layer effects.
		double maxiabs = 0.6;	// Maximum initial abstraction ratio
		double smx;				// Soil storage available for surface water based on CN formula	(mm)
		double pb;				// Determines threshold amount of rainfall that will occur before runoff starts (mm/d)
		
		smx = 254.0 * (100.0/cn - 1.0);
		
		// Uses only two firsts layers to compute runoff
		SoilLayer sl1 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 1));
		SoilLayer sl2 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 2));
		
		swabi = Math.max(0, 0.15 * ((sl1.SAT - sl1.SWC)/(sl1.SAT - sl1.LL * 0.5) + (sl2.SAT - sl2.SWC)/(sl2.SAT - sl2.LL * 0.5)));
		
		if(mulchEffect){
		iabs = swabi + (maxiabs - swabi) * mulch;
		}else{
		iabs = swabi;
		}
		
		pb = watavl - iabs * smx;
		
		if(watavl > 0.001){
			if(pb > 0){
				runoff =  pb**2/(watavl + (1-iabs) * smx);
			}else{
				runoff =  0.0;
			}		
		}else{		
			runoff =  0.0;
		}		
		
	}
	
	// Water infiltration calculations
	void infiltration(){
		
		double drcm;
		double hold;
		double tmpexcs;
		double[] drn 		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		double[] swdelts	= new double[nLayers];
		
		//double[] dlayr 	= new double[nLayers];
		//double[] dul	= new double[nLayers];
		//double[] sat	= new double[nLayers];
		
		for(int L = 0; L<=nLayers-1; L++){
		
			drn[L] 		= 0.0;
			swdelts[L]	= 0.0;		
		}
		
		excs 			= 0.0;
		tmpexcs			= 0.0;
		
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;			
			hold = (sl.SAT - swtemp[L]) * sl.Thickness;
			
			if(pinf > 0.001 && pinf > hold){
				
				if(L==0){
					drcm = 0.9 * swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}else{
					drcm = swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}
			
				drn[L] = pinf - hold + drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT * 24.0){					
					drn[L] 	= sl.KSAT * 24.0;
					drcm	= drn[L] + hold - pinf;
				}
				
				swtemp[L] = swtemp[L] + (pinf - drn[L])/sl.Thickness;
				
				if(swtemp[L] > sl.SAT){
					
					tmpexcs = (swtemp[L] - sl.SAT) * sl.Thickness;
					swtemp[L] = sl.SAT;
					
					if(L==0 && tmpexcs > 0.0){
						excs += tmpexcs;
					}
					
					if(L > 0){
						int Lup = L-1;
						
						while(tmpexcs > 0.0001 && Lup >=0){
							
							SoilLayer slup = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (Lup+1)));	
							hold = Math.min((slup.SAT - swtemp[Lup])*slup.Thickness,tmpexcs);
							swtemp[Lup] = swtemp[Lup] + hold / slup.Thickness;
							drn[Lup] = Math.max(drn[Lup] - tmpexcs,0);
							tmpexcs = tmpexcs - hold;
							
							if(Lup == 0 && tmpexcs > 0.0001){
							excs = excs + tmpexcs;
							}					
						}				
					}				
				}
				
				pinf = drn[L];
				
			}else{
			
			swtemp[L] = swtemp[L] + pinf / sl.Thickness;
			if(swtemp[L] >= sl.DUL + 0.003){
				
				if(L ==0){
					drcm = 0.9 * (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}else{
					drcm = (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}
				
				drn[L] = drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT*24.0){
					drn[L] = sl.KSAT*24.0;
					drcm = drn[L];				
				}
				
				swtemp[L] = swtemp[L] - drcm / sl.Thickness;
				pinf = drcm;
			
			}else{				
				pinf 	= 0.0;
				drn[L] 	= 0.0;			
			}			
			}
			
			swdelts[L] = swtemp[L] - sl.SWC;
			infilt = infilt + swdelts[L] * sl.Thickness * 10.;			
		}
		
		drain = pinf * 10.0;		
	}
	
	// Saturated flow calculations
	void SatFlow(){
		
		double drcm;
		double hold;
		double tmpexcs;
		double swold;
		double[] drn 		= new double[nLayers];
		double[] drmx		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		double[] swdelts	= new double[nLayers];
		
		
		//double[] dlayr 	= new double[nLayers];
		//double[] dul	= new double[nLayers];
		//double[] sat	= new double[nLayers];
		
				
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;
			drn[L] 		= 0.0;
			drmx[L]		= 0.0;
			swdelts[L]	= 0.0;
			
			if(swtemp[L] >= (sl.DUL + 0.003)){
				
				drmx[L] = Math.max(0,(swtemp[L] - sl.DUL) * swcon * sl.Thickness);
				
			}
			
			if(L == 0){
			
				drn[L] = drmx[L];
			}else{
			
				hold = 0.0;
				if(swtemp[L] < sl.DUL){
				hold = (sl.DUL - swtemp[L]) * sl.Thickness;
				}
				
				drn[L] = Math.max(0,drn[L-1] + drmx[L] - hold);
			}
			
			if(sl.KSAT > 0 && drn[L] > sl.KSAT*24.0){
			drn[L] = sl.KSAT * 24.0;
			}
			
			
			
		}//end of main loop
	
		for(int L = nLayers-1; L>=1; L--){
			
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swold = swtemp[L];
			swtemp[L] = swtemp[L] + (drn[L-1] - drn[L]) / sl.Thickness;
			if(swtemp[L] > sl.SAT){
			drn[L-1] = Math.max(0,(sl.SAT - swold) * sl.Thickness + drn[L]);
			swtemp[L] = sl.SAT;
			}		
		}
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
		swtemp[0] = swtemp[0] - drn[0] / sl.Thickness;
		drain = drn[nLayers-1] * 10;
		
		//Calculating the dwc/dt
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl_dt = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swdelts[L] = swtemp[L] - sl_dt.SWC;
		
		}
	
	}

	void WaterBalance(){
		
		double swdeltu;
		double swdeltt;
		double swdeltl;
		
		// Daily rate calculations
		
		//check whether snow is happening
		if(tmax <= 1 && snow > 0.001){		
			// compute snow contribution to water income
		}else{
		watavl = rain;
		}
		
		//check if all rate variables are set to zero here... <<<<<<<<
		
		//condition when the field is pudded
		if(puddled){
		//compute conditions for puddled fields...
		
		}else{
			
		//non-puddled, flooded or non-flooded field		
		pinf 	= 0.;
		winf	= 0.;
		infilt	= 0.;
		
		// Bunded field (rice)?
		if(bunded){		
			runoff = 0.;
			winf = Math.max(0, flood + irrig + rain); //(mm)					
		}else{
		// Upland field
		// Not bunded, flooded conditions not possible (this is not Holland)
		
		//water first absorbed by mulch, if presents
		if(mulchEffect){
		//Ritchie mulch effect model
		}
		
		// Compute runoff
		runoff();		
		winf = watavl - runoff + irrig; //(mm)	
		
		}
		
		// potential for infiltration
		pinf = winf * 0.1;				//(cm)
		
		//call infiltration() method to calculate infiltration rates on days with irrigation or rainfall.
		//call SatFlow() method on days with no irrigation or rain to calulate satirated flow.		
		if(pinf > 0.0001){			
			
			// calculating the amount of water for intiltration (infilt, drain, drn, excs, swdelts)
			infilt = 0.0;
			infiltration();			
			infilt = infilt + drain;
			
			//Excess water not infiltrated is added to overland runoff
			//if bunded, excess water is accounted for in infilt variable
			if(excs > 0 && bunded == false){
			runoff = runoff + excs * 10.0;
			}		
		}else{			
			SatFlow();					
		}
		
		if(tdlno > 0){
		//tiledrain computation...
		}
		
		}
		
		///////////////////////////TO BE CONTINUE .............
		
		if(flood <= 0.0){}
		
		
		
		
		
	}//end of method
	
	
	
	void initiate(int TileRow, int TileStrip){
		
		row 	= TileRow;
		strip 	= TileStrip;
		cn		= cn_runoff;
		swcon	= swcon_runoff;
		nLayers	= Layer_Depth.length;
		tdlno	= 0;
		pinf	= 0.;
		winf	= 0.;
		infilt	= 0.;
		watavl	= 0.;
		drain	= 0.;
		flood	= 0.; // no flood <--- should be at parameters
		
		//Flag conditions
		puddled			= false;
		bunded			= false;
		mulchEffect		= false;
	}

	
	
}