import static parameters.*;
import static environment.*;
import static modules_base.*;
import static modules_light.*;

import de.grogra.ray.physics.Spectrum;
import de.grogra.ray.physics.Spectrum3d;

// soil profile associated to an individual plant
module SoilLayer
{
	int    row;
	int	   strip;
	int    rank;
	double upper;
	double bottom;
	double LL;
	double DUL;
	double SAT;
	double KSAT;
	double BDEN;
	double SLOC;
	double Thickness;
	double PlantDist;
	double RowDist;
	double Depth;
	double SWC;
	double TSWC;
	
	void initialConditions(){
	
		SWC = DUL;
		TSWC = SWC * Thickness;
	}
	
	
	void infil(){
	}
	
	void satflow(){
	}
	
	
	

	// initiation of a soil layer
	void initiate(int nLayer, int TileRow, int TileStrip)
	{
		rank 	= nLayer;
		row  	= TileRow;
		strip 	= TileStrip;
		Depth 	= Layer_Depth[nLayer-1] * 100.;
		LL 		= Layer_LL[nLayer-1];
		DUL 	= Layer_DUL[nLayer-1];
		SAT		= Layer_SAT[nLayer-1];
		KSAT	= Layer_KSAT[nLayer-1];
		BDEN	= Layer_BDEN[nLayer-1];
		SLOC	= Layer_SLOC[nLayer-1];
		
		if(nLayer == 1){
			Thickness = Layer_Depth[nLayer-1]* 100.0;			
		}else{
			Thickness = (Layer_Depth[nLayer-1] - Layer_Depth[nLayer-2]) * 100.0;
		}
		Thickness = 0.001*Math.round(1000*Thickness);
		upper = Depth - Thickness;
		bottom = Depth;
		
		PlantDist = 0.25;
		RowDist = 1.4;
		
		if(nLayer == 1) {Depth = Depth + 0.001;}
		
		
	}
} 
==> 
Translate(0,0,-Depth/100.) Box(Thickness/100.,PlantDist,RowDist).(setColor(0.51,0.33,0.16))
;

module SoilProfile() extends Null{
	
	int		row;
	int		strip;
	int		cn;
	int		nLayers;
	int		tdlno;
	double	swcon;
	double 	runoff;
	double	watavl;
	double  winf;		//Water available for infiltration - rainfall minus runoff plus  net irrigation (mm / d)
	double  pinf;
	double drain;
	double infilt;
	double flood;
	double excs; // check if here is the right place for it
	boolean puddled;
	boolean bunded;
	boolean initiate;
	
	boolean mulchEffect;
	double mulch;
	
	double crain;
	double tdrain;
	double trunof;
	double tswini;
	double tsw;
	
	String mesev = "S";
	
	double[] swdeltt		= new double[Layer_Depth.length];
	double[] swdeltl		= new double[Layer_Depth.length];	
	double[] sw_avail		= new double[Layer_Depth.length];
	double[] swdelts		= new double[Layer_Depth.length];
	double[] swdeltu		= new double[Layer_Depth.length];
	double[] swdeltx		= new double[Layer_Depth.length];
	double[] sw_mm_NEW		= new double[Layer_Depth.length];	
	double[] sw_mm			= new double[Layer_Depth.length];
	double[] swdelts_mm		= new double[Layer_Depth.length];
	double[] swdeltx_mm		= new double[Layer_Depth.length];
	double[] swdeltl_mm		= new double[Layer_Depth.length];
	double[] swdeltu_mm		= new double[Layer_Depth.length];
	double[] swdeltt_mm		= new double[Layer_Depth.length];
	
	double[] es_lyr			= new double[Layer_Depth.length];
	double[] upflow			= new double[Layer_Depth.length];
	double aesoil;
	double aeosoil;
	
	
	double[] satfrac		= new double[nLayers];
	
	// Run-off calculations
	void Runoff(){
		
		double swabi;			// A soil water abstraction index, a unitless indicator of the soil water condition at the time of a rainfall event.  This affects the intercept of the runoff axis when runoff starts to occur--later when drier and sooner when wetter.
		double iabs;			// Initial abstraction ratio, modified for surface mulch layer effects.
		double maxiabs = 0.6;	// Maximum initial abstraction ratio
		double smx;				// Soil storage available for surface water based on CN formula	(mm)
		double pb;				// Determines threshold amount of rainfall that will occur before runoff starts (mm/d)
		
		smx = 254.0 * (100.0/cn - 1.0);
		
		// Uses only two top layers to compute runoff
		SoilLayer sl1 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 1));
		SoilLayer sl2 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 2));

		swabi = Math.max(0, 0.15 * ((sl1.SAT - sl1.SWC)/(sl1.SAT - sl1.LL * 0.5) + (sl2.SAT - sl2.SWC)/(sl2.SAT - sl2.LL * 0.5)));
		
		if(mulchEffect){
		iabs = swabi + (maxiabs - swabi) * mulch;
		}else{
		iabs = Math.min(swabi,maxiabs);
		}
		
		pb = watavl - iabs * smx;
		
		
		if(watavl > 0.001){
			if(pb > 0){
				runoff =  pb**2/(watavl + (1-iabs) * smx);
			}else{
				runoff =  0.0;
			}		
		}else{		
			runoff =  0.0;
		}		
		
	}
	
	// Water infiltration calculations
	void Infiltration(){
		
		double drcm;
		double hold;
		double tmpexcs;
		double[] drn 		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		
		excs 			= 0.0;
		tmpexcs			= 0.0;
		
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;
			
			hold = (sl.SAT - swtemp[L]) * sl.Thickness;			
			
			if(pinf > 0.001 && pinf > hold){
				
				if(L==0){
					drcm = 0.9 * swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}else{
					drcm = swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}
			
				drn[L] = pinf - hold + drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > (sl.KSAT * 24.0)){					
					drn[L] 	= sl.KSAT * 24.0;
					drcm	= drn[L] + hold - pinf;
				}
				
				swtemp[L] = swtemp[L] + (pinf - drn[L])/sl.Thickness;
				
				if(swtemp[L] > sl.SAT){
					
					tmpexcs = (swtemp[L] - sl.SAT) * sl.Thickness;
					swtemp[L] = sl.SAT;
					
					if(L==0 && tmpexcs > 0.0){
						excs = excs + tmpexcs;
					}
					
					if(L > 0){
						int Lup = L-1;
						
						while(tmpexcs > 0.0001 && Lup >=0){
							
							SoilLayer slup = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (Lup+1)));
				
							hold = Math.min((slup.SAT - swtemp[Lup])*slup.Thickness,tmpexcs);
							swtemp[Lup] = swtemp[Lup] + hold / slup.Thickness;
							drn[Lup] = Math.max(drn[Lup] - tmpexcs,0);
							tmpexcs = tmpexcs - hold;
							
							if(Lup == 0 && tmpexcs > 0.0001){
							excs = excs + tmpexcs;
							}					
						}				
					}				
				}
				
				pinf = drn[L];
				
			}else{
			
			swtemp[L] = swtemp[L] + pinf / sl.Thickness;
			if(swtemp[L] >= (sl.DUL + 0.003)){
				
				if(L ==0){
					drcm = 0.9 * (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}else{
					drcm = (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}
				
				drn[L] = drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > (sl.KSAT*24.0)){
					drn[L] = sl.KSAT*24.0;
					drcm = drn[L];				
				}
				
				swtemp[L] = swtemp[L] - drcm / sl.Thickness;
				pinf = drcm;
			
			}else{				
				pinf 	= 0.0;
				drn[L] 	= 0.0;			
			}			
			}
			
			swdelts[L] = swtemp[L] - sl.SWC;			
			infilt = infilt + swdelts[L] * sl.Thickness * 10.;
			
		}
		
		drain = pinf * 10.0;
		
		// DLAYR(L)   Thickness of soil layer L (cm)
		// DRAIN       Drainage rate from soil profile (mm/d)
		// DRCM        Drainage rate from soil profile (cm/d)
		// DRN(L)      Drainage rate through soil layer L (cm/d)
		// DUL(L)      Volumetric soil water content at Drained Upper Limit in soil layer L (cm3[water]/cm3[soil])              
		// EXCS       Excess water to be added to runoff (cm/d)
		// HOLD        Amount of water a soil layer will hold above it's present level, used to calculate downward flow; also, temporary  variable/ intermediate calculation (cm)         
		// NLAYR       Actual number of soil layers 
		// PINF       Potential water available for infiltration (cm)
		// SAT(L)      Volumetric soil water content in layer L at saturation  (cm3 [water] / cm3 [soil])
		// SW(L)       Volumetric soil water content in layer L (cm3 [water] / cm3 [soil])
		// SWCN(L)     Saturated hydraulic conductivity in layer L (cm/hr)
		// SWCON       Soil water conductivity constant; whole profile drainage rate  coefficient (1/d)              
		// SWDELTS(L) Change in soil water content due to drainage in layer L (cm3 [water] / cm3 [soil])             
		// SWTEMP(L)   Soil water content in layer L (temporary value to be modified based on drainage, root uptake and upward flow through soil  layers). (cm3/cm3)
			
	}
	
	// Saturated flow calculations
	void SatFlow(){
		
		//double drcm;
		double hold;
		double tmpexcs;
		double swold;
		double[] drn 		= new double[nLayers];
		double[] drmx		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		
				
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));			
			swtemp[L]	= sl.SWC;
						
			if(swtemp[L] >= (sl.DUL + 0.003)){							
				
				drmx[L] = Math.max(0,(swtemp[L] - sl.DUL) * swcon * sl.Thickness);
				
			}
			
			if(L == 0){
			
				drn[L] = drmx[L];
			}else{
			
				hold = 0.0;
				if(swtemp[L] < sl.DUL){
				hold = (sl.DUL - swtemp[L]) * sl.Thickness;
				}
				
				drn[L] = Math.max(0,drn[L-1] + drmx[L] - hold);
			}
			
			if(sl.KSAT > 0 && drn[L] > (sl.KSAT*24.0)){
			drn[L] = sl.KSAT * 24.0;
			}
			
			
			
		}//end of main loop
	
		
		//Compute volumetric water contents after drainage in a day.
		//Prevent water content in any layer from exceeding saturation as water drains down in the profile.
   
		for(int L = nLayers-1; L>=1; L--){
			
			SoilLayer slb = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swold = swtemp[L];
			swtemp[L] = swtemp[L] + (drn[L-1] - drn[L]) / slb.Thickness;
			
			if(swtemp[L] > slb.SAT){
			drn[L-1] = Math.max(0,(slb.SAT - swold) * slb.Thickness + drn[L]);
			swtemp[L] = slb.SAT;
			}
			
		}
		
		SoilLayer sltop = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
		swtemp[0] = swtemp[0] - drn[0] / sltop.Thickness;
		drain = drn[nLayers-1] * 10;
		
		//Calculating the dwc/dt
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl_dt = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swdelts[L] = swtemp[L] - sl_dt.SWC;
						
		
		}
	
	}
	
	
	void UpFlow(){
	
	int	ist;
	int M;
	double swold;
	double thet1;
	double thet2;
	double dbar;
	double grad;
	double flowfix;	
	
	double[] swtemp		= new double[nLayers];
	double[] sw_inf		= new double[nLayers];	
	double[] esw		= new double[nLayers];
	
	for(int L = 0; L<=nLayers-1; L++){
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		
		upflow[L] = 0.0;
		swdeltu[L] = 0.0;
		swtemp[L] = sl.SWC;
		sw_inf[L] = sw_avail[L]; // sw_avail has been calculated previously on SatFlow method
		sw_avail[L] = Math.max(0., sw_avail[L] - sl.DUL);
		esw[L] = sl.DUL - sl.LL;	
	
	}
	
	SoilLayer top_sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
	
	if(top_sl.Thickness >= 5.0){ist=0;}else{ist=1;}
	
	for(int L = ist; L<=nLayers-2; L++){
		M = L + 1;
		swold = swtemp[L];
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		SoilLayer sl_M = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (M+1)));
		
		thet1 = Math.max(0,Math.min(swtemp[L] - sl.LL, esw[L]));
		thet2 = Math.max(0,Math.min(swtemp[M] - sl_M.LL, esw[M]));
		
		dbar = 0.88 * Math.exp(35.4 * ((thet1*sl.Thickness + thet2*sl_M.Thickness)/(sl.Thickness + sl_M.Thickness))* 0.5);
		dbar = Math.min(dbar,100.);
		
		grad = (thet2/esw[M] - thet1/esw[L]) * (esw[M] * sl_M.Thickness + esw[L] * sl.Thickness) / (sl_M.Thickness + sl.Thickness);
		
		upflow[L] = dbar * grad / ((sl.Thickness + sl_M.Thickness)*0.5);
		
		//upward flow from layer M to L
		
		if(upflow[L] > 0.){
		
			if(swtemp[L] <= sl.DUL){
			
				swtemp[L] = swtemp[L] + upflow[L] / sl.Thickness;
				sw_inf[L] = sw_inf[L] + upflow[L] / sl.Thickness;
				
				if(swtemp[L] > sl.DUL || sw_inf[L] > sl.SAT){
					
					flowfix = Math.max(0., ((swtemp[L] - sl.DUL) * sl.Thickness));
					flowfix = Math.max(flowfix, ((sw_inf[L] - sl.SAT) * sl.Thickness));
					flowfix = Math.min(upflow[L], flowfix);
					upflow[L] = upflow[L] - flowfix;
					swtemp[L] = swold + upflow[L] / sl.Thickness;		
				
				}
			
			}else{				
				upflow[L] = 0.;							
			}
			
			if(upflow[L] / sl.Thickness > sw_avail[M]){
			
				upflow[L] = sw_avail[M] * sl_M.Thickness;
				swtemp[L] = swold + upflow[L] / sl.Thickness;
			
			}
			
			swtemp[M] = swtemp[M] - upflow[L] / sl_M.Thickness;
		
		//downward flow from layer L to M
		}else if(upflow[L] < 0.){
			
			if(swtemp[L] >= sl.LL){
			
				if(Math.abs(upflow[L] / sl.Thickness) > sw_avail[L]){
				
					upflow[L] = -sw_avail[L] * sl.Thickness;
				
				}
				
				swtemp[L] = swtemp[L] + upflow[L] / sl.Thickness;
				swtemp[M] = swtemp[M] - upflow[L] / sl_M.Thickness;
				sw_inf[M] = sw_inf[M] - upflow[L] / sl_M.Thickness;
				
				if(sw_inf[M] > sl_M.SAT){
					
					flowfix = Math.min(Math.abs(upflow[L]), (sw_inf[M] - sl_M.SAT) * sl_M.Thickness);
					upflow[L] = upflow[L] + flowfix;
					swtemp[L] = swold + upflow[L] / sl.Thickness;
					swtemp[M] = swtemp[M] - flowfix / sl_M.Thickness;
				
				}
			
				// no downwar movement if swtemp < LL
			}else{
			
				upflow[L] = 0.;
			
			}
		
		}
		
	
	}//end of main loop
	
	
	for(int L = 0; L<=nLayers-1; L++){		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		swdeltu[L] = swtemp[L] - sl.SWC;	
		}	
	}
	
	void wbsum(){		
		
		tsw = sum((* sl:SoilLayer, (sl.row == row && sl.strip == strip) *)[TSWC]);
		crain += rain;
		tdrain += drain;
		trunof += runoff;
		
		
		// sum of initial conditions
		if(dayOfYear == (startingDayOfYear+1) && year == (startingyear)){
		
			crain 	= 0.;
			tdrain	= 0.;
			trunof	= 0.;
			tswini	= 0.;
			
			tswini = sum((* sl:SoilLayer, (sl.row == row && sl.strip == strip) *)[SWC]);
			tsw = tswini;		
		
		}	
	
	}
	
	void wtdept(){
		
		double tol = 0.95;
		
		
	for(int L = nLayers-1; L>=0; L--){
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		
		satfrac[L] = (sl.SWC - sl.DUL) / (sl.SAT - sl.DUL);
		satfrac[L] = Math.min(Math.max(0.0, satfrac[L]), 1.0);		

	}	
	}
	
	void SoilEvaporation(){
		
		int profile_type;		
		double sw_threshold;
		double a_val;
		double b_val;
		double red_factor;
		
		double[] swad		= new double[nLayers];
		double[] meandep	= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		double[] es_coef	= new double[nLayers];
		
		profile_type = 3;
		
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			// Air dry water content
			swad[L] = 0.3 * sl.LL;
			
			// Mean depth for each soil layer
			meandep[L] = sl.Depth - sl.Thickness / 2.; //(cm)
			
			if(swdelts[L] > 0.0){
			
				swtemp[L] = sl.SWC + 0.5 * swdelts[L];
			
			}else{
			
				swtemp[L] = sl.SWC + swdelts[L];
			}
			
			if(meandep[L] < 100. && swtemp[L] > sl.DUL){
			
				profile_type = 1;
			}		
			
			
		}
		
		if(profile_type == 1){
		
			SoilLayer sl_top = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
			sw_threshold = 0.275 * sl_top.DUL + 1.165 * sl_top.DUL * sl_top.DUL + (1.2 * sl_top.DUL ** 3.75) * meandep[0];
			
			if(swtemp[0] < sw_threshold){
				profile_type = 2;			
			}		
		}
		
		for(int L = 0; L<=nLayers-1; L++){
			
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			switch(profile_type){
			
			case 3:
			a_val =   0.5 + 0.24 * sl.DUL;
			b_val = -2.04 + 0.20 * sl.DUL;
			es_coef[L] = a_val * meandep[L] ** b_val;
			
			case 2:
			
			es_coef[L] = 0.011;
			
			case 1:
			
			a_val =  0.26;
			b_val = -0.70;
			es_coef[L] = a_val * meandep[L] ** b_val;
		
		}
		
		swdeltu[L] = -(swtemp[L] - swad[L]) * es_coef[L]; // (mm3/mm3)
		
		sw_avail[L] = sl.SWC + swdelts[L] - swad[L];
		
		if(-swdeltu[L] > sw_avail[L]){
		
			swdeltu[L] = -sw_avail[L];
			
		}
		
		// To limit evaporation only as water withdraw
		swdeltu[L] = Math.min(0.,swdeltu[L]);
		
		es_lyr[L] = -swdeltu[L] * sl.Thickness * 10.0;	// (mm)		
		aesoil = aesoil + es_lyr[L];					// profile sum (mm)		
			
		}
		
		// Limit total profile soil evaporation to potential soil evaporation
		red_factor = 1.0;
		
		if(aesoil > aeosoil){
			red_factor = aeosoil / aesoil;
			es_lyr[0:nLayers-1] = es_lyr[0:nLayers-1] * red_factor;
			swdeltu[0:nLayers-1] = swdeltu[0:nLayers-1] * red_factor;
			aesoil = aeosoil;		
		}
		
		upflow[0:nLayers-1] = 0.0;
		upflow[nLayers-1] = es_lyr[nLayers-1] / 10.;
		
		for(int L = nLayers-2; L>=0; L--){
		
			upflow[L] = upflow[L+1] + es_lyr[L] / 10.;
		
		}		
		
	
	
	}
	

	void WaterBalance(){	
		
	
		// -----------------------
		// Daily rate calculations
		// -----------------------	
		
		//check whether snow is happening
		if(tmax <= 1 && snow > 0.001){		
			// compute snow contribution to water income
		}else{
		watavl = rain;
		}
		
		// set process rates to zero
		pinf 				 = 0.;
		winf				 = 0.;
		infilt				 = 0.;
		drain				 = 0.;
		excs				 = 0.;		
		swdelts[0:nLayers-1] = 0.;
		swdeltu[0:nLayers-1] = 0.;
		swdeltt[0:nLayers-1] = 0.;
		swdeltl[0:nLayers-1] = 0.;
		
		//condition when the field is pudded
		if(puddled){
		//compute conditions for puddled fields (To be constructed)		
		}else{		
		
		// Bunded field (rice)?
		if(bunded){		
			runoff = 0.;
			winf = Math.max(0, flood + irrig + rain); //(mm)					
		}else{
		// Upland field
		// Not bunded, flooded conditions not possible (this is not Holland)
		
		//water first absorbed by mulch, if presents
		if(mulchEffect){
		//Ritchie mulch effect model (To be constructed)
		}	
		
		// Compute runoff
		Runoff();
						
		winf = watavl - runoff + irrig; //(mm)	
		
		}		
				
		// potential for infiltration
		pinf = winf * 0.1;				//(cm)
		
		//call infiltration() method to calculate infiltration rates on days with irrigation or rainfall.
		//call SatFlow() method on days with no irrigation or rain to calulate satirated flow.		
		if(pinf > 0.0001){	
			
			// calculating the amount of water for intiltration (infilt, drain, drn, excs, swdelts)
			infilt = 0.0;
			Infiltration();			
			infilt = infilt + drain;
						
			//Excess water not infiltrated is added to overland runoff
			//if bunded, excess water is accounted for in infilt variable
			if(excs > 0 && bunded == false){
			runoff = runoff + excs * 10.0;
			}
			
		}else{
			
			SatFlow();
			
		}
		
		if(tdlno > 0){
		//tiledrain computation...
		}
		
		}
		
		
		// Should be used only when evaporation method is not the default (Sulieman-Ritchie 2006)
		if(flood <= 0.0 && mesev != "S"){
			
			for(int L = 0; L<=nLayers-1; L++){
				
				SoilLayer sl_dt = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
				sw_avail[L]	= Math.max(0., sl_dt.SWC + swdelts[L]);
			}
			
			UpFlow();		
		}
		
		// to be constructed to account for tillage effect on swc
		//if(tillage){}
		
		
		// -----------------------
		// Daily integration
		// -----------------------
		
		//perform integration of soil water fluxes
		// substract soil evaporation from layer 1
		
		for(int L = 0; L<=nLayers-1; L++){
			
			
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			sw_mm[L] 		= sl.SWC 		* sl.Thickness * 10.;
			swdelts_mm[L]	= swdelts[L] 	* sl.Thickness * 10.; 
			swdeltx_mm[L]	= swdeltx[L] 	* sl.Thickness * 10.;
			swdeltl_mm[L]	= swdeltl[L] 	* sl.Thickness * 10.;
			swdeltu_mm[L]	= swdeltu[L] 	* sl.Thickness * 10.;
			swdeltt_mm[L]	= swdeltt[L] 	* sl.Thickness * 10.;			
						
			sw_mm_NEW[L] = sw_mm[L] + swdelts_mm[L] + swdeltu_mm[L] + swdeltl_mm[L] + swdeltx_mm[L] + swdeltt_mm[L];
				
			sl.SWC = sw_mm_NEW[L] / sl.Thickness / 10.;
			sl.TSWC = sl.SWC * sl.Thickness;
			
		}
		
		// Perform daily summation of water balance variables.
		wbsum();
		
	}
	
	
	void initiate(int TileRow, int TileStrip){
		
		row 	= TileRow;
		strip 	= TileStrip;
		cn		= cn_runoff;
		swcon	= swcon_drain;
		nLayers	= Layer_Depth.length;
		tdlno	= 0;
		pinf	= 0.;
		winf	= 0.;
		infilt	= 0.;
		watavl	= 0.;
		drain	= 0.;
		flood	= 0.; // no flood <--- should be at parameters
		
		//Flag conditions
		puddled			= false;
		bunded			= false;
		mulchEffect		= false;
	}
	
	
//     VARIABLE DEFINITIONS: (updated 12 Feb 2004)
//-----------------------------------------------------------------------
// BUNDED      Logical variable indicating if field is currently bunded 
// CN          Runoff Curve Number - measure of runoff potential based on 
//               soil type and current soil water content. 
// CONTROL     Composite variable containing variables related to control 
//               and/or timing of simulation.    See Appendix A. 
// CRAIN       Cumulative precipitation (mm)
// DLAYR(L)    Thickness of soil layer L (cm)
// DRAIN       Drainage rate from soil profile (mm/d)
// DRN(L)      Drainage rate through soil layer L (cm/d)
// DS(L)       Cumulative depth in soil layer L (cm)
// DUL(L)      Volumetric soil water content at Drained Upper Limit in soil 
//               layer L (cm3[water]/cm3[soil])
// ES          Actual soil evaporation rate (mm/d)
// EXCS        Excess water to be added to runoff (cm/d)
// FLOOD       Current depth of flooding (mm)
// FLOODWAT    Composite variable containing information related to bund 
//               management. Structure of variable is defined in 
//               ModuleDefs.for. 
// UPFLOW(L)   Movement of water between unsaturated soil layers due to soil 
//               evaporation: + = upward, -- = downward (cm/d)
// INFILT      Infiltration rate (mm / d)
// IRRAMT      Irrigation amount for today (mm / d)
// ISWWAT      Water simulation control switch (Y or N) 
// LL(L)       Volumetric soil water content in soil layer L at lower limit
//              (cm3 [water] / cm3 [soil])
// NLAYR       Actual number of soil layers 
// PINF        Potential water available for infiltration (cm)
// PUDDLED     Logical variable indicating whether lowland field has been 
//               puddled 
// PUDPERC     Potential percolation rate for puddled field (mm/d)
// RAIN        Precipitation depth for current day (mm)
// RUNOFF      Calculated runoff (mm/d)
// SAT(L)      Volumetric soil water content in layer L at saturation
//              (cm3 [water] / cm3 [soil])
// SNOW        Snow accumulation (mm)
// SW(L)       Volumetric soil water content in layer L
//              (cm3 [water] / cm3 [soil])
// SW_AVAIL(L) Soil water content in layer L available for evaporation, 
//               plant extraction, or movement through soil
//               (cm3 [water] / cm3 [soil])
// SWCN(L)     Saturated hydraulic conductivity in layer L (cm/hr)
// SWCON       Soil water conductivity constant; whole profile drainage rate 
//               coefficient (1/d)
// SWDELTS(L)  Change in soil water content due to drainage in layer L
//              (cm3 [water] / cm3 [soil])
// SWDELTU(L)  Change in soil water content due to evaporation and/or upward 
//               flow in layer L (cm3 [water] / cm3 [soil])
// SWDELTX(L)  Change in soil water content due to root water uptake in 
//               layer L (cm3 [water] / cm3 [soil])
// TDRAIN      Cumulative daily drainage from profile (mm)
// TMAX        Maximum daily temperature (°C)
// TRUNOF      Cumulative runoff (mm)
// TSW         Total soil water in profile (cm)
// TSWINI      Initial soil water content (cm)
// WATAVL      Water available for infiltration or runoff (rainfall plus 
//               irrigation) (mm/d)
// WINF        Water available for infiltration - rainfall minus runoff plus 
//               net irrigation (mm / d)
// WTDEP       Depth to water table (cm)

	
	
}