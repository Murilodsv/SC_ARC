import static parameters.*;
import static environment.*;
import static modules_base.*;
import static modules_light.*;

import de.grogra.ray.physics.Spectrum;
import de.grogra.ray.physics.Spectrum3d;

// soil profile associated to an individual plant
module SoilLayer
{
	int    row;
	int	   strip;
	int    rank;
	double upper;
	double bottom;
	double LL;
	double DUL;
	double SAT;
	double KSAT;
	double BDEN;
	double SLOC;
	double Thickness;
	double PlantDist;
	double RowDist;
	double Depth;
	double SWC;
	double TSWC;
	
	void initialConditions(){
	
		SWC = DUL;
	}
	
	
	void infil(){
	}
	
	void satflow(){
	}
	
	void upflow(){
	}
	

	// initiation of a soil layer
	void initiate(int nLayer, int TileRow, int TileStrip)
	{
		rank 	= nLayer;
		row  	= TileRow;
		strip 	= TileStrip;
		Depth 	= Layer_Depth[nLayer-1];
		LL 		= Layer_LL[nLayer-1];
		DUL 	= Layer_DUL[nLayer-1];
		SAT		= Layer_SAT[nLayer-1];
		KSAT	= Layer_KSAT[nLayer-1];
		BDEN	= Layer_BDEN[nLayer-1];
		SLOC	= Layer_SLOC[nLayer-1];
		
		Thickness = (nLayer == 1 ? Layer_Depth[nLayer-1]:(Layer_Depth[nLayer-1] - Layer_Depth[nLayer-2]));
		upper = Depth - Thickness;
		bottom = Depth;
		
		PlantDist = 0.25;
		RowDist = 1.4;
		
		if(nLayer == 1) {Depth = Depth + 0.001;}
		
		
	}
} 
==> 
Translate(0,0,-Depth) Box(Thickness,PlantDist,RowDist).(setColor(0.51,0.33,0.16))
;

module SoilProfile() extends Null{
	
	int		row;
	int		strip;
	int		cn;
	int		nLayers;
	int		tdlno;
	double	swcon;
	double 	runoff;
	double	watavl;
	double  winf;		//Water available for infiltration - rainfall minus runoff plus  net irrigation (mm / d)
	double  pinf;
	double drain;
	double infilt;
	double flood;
	double excs; // check if here is the right place for it
	boolean puddled;
	boolean bunded;
	boolean initiate;
	
	boolean mulchEffect;
	double mulch;
	
	double crain;
	double tdrain;
	double trunof;
	double tswini;
	double tsw;
	
	double[] sw_avail	= new double[nLayers];
	double[] swdelts	= new double[nLayers];
	double[] swdeltu	= new double[nLayers];
	double[] swdeltx	= new double[nLayers];
	double[] sw_mm_NEW	= new double[nLayers];
	
	double[] sw_mm			= new double[nLayers];
	double[] swdelts_mm		= new double[nLayers];
	double[] swdeltx_mm		= new double[nLayers];
	double[] swdeltl_mm		= new double[nLayers];
	double[] swdeltu_mm		= new double[nLayers];
	double[] swdeltt_mm		= new double[nLayers];
	
	
	double[] satfrac		= new double[nLayers];
	
	// Run-off calculations
	void Runoff(){
		
		//cn = curve number - measure of runoff potential based on soil type and current soil water content. 
		//watavl = rain + irrigation;
		
		double swabi;			// A soil water abstraction index, a unitless indicator of the soil water condition at the time of a rainfall event.  This affects the intercept of the runoff axis when runoff starts to occur--later when drier and sooner when wetter.
		double iabs;			// Initial abstraction ratio, modified for surface mulch layer effects.
		double maxiabs = 0.6;	// Maximum initial abstraction ratio
		double smx;				// Soil storage available for surface water based on CN formula	(mm)
		double pb;				// Determines threshold amount of rainfall that will occur before runoff starts (mm/d)
		
		smx = 254.0 * (100.0/cn - 1.0);
		
		// Uses only two firsts layers to compute runoff
		SoilLayer sl1 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 1));
		SoilLayer sl2 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 2));
		
		swabi = Math.max(0, 0.15 * ((sl1.SAT - sl1.SWC)/(sl1.SAT - sl1.LL * 0.5) + (sl2.SAT - sl2.SWC)/(sl2.SAT - sl2.LL * 0.5)));
		
		if(mulchEffect){
		iabs = swabi + (maxiabs - swabi) * mulch;
		}else{
		iabs = swabi;
		}
		
		pb = watavl - iabs * smx;
		
		if(watavl > 0.001){
			if(pb > 0){
				runoff =  pb**2/(watavl + (1-iabs) * smx);
			}else{
				runoff =  0.0;
			}		
		}else{		
			runoff =  0.0;
		}		
		
	}
	
	// Water infiltration calculations
	void Infiltration(){
		
		double drcm;
		double hold;
		double tmpexcs;
		double[] drn 		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		
		
		//double[] dlayr 	= new double[nLayers];
		//double[] dul	= new double[nLayers];
		//double[] sat	= new double[nLayers];
		
		for(int L = 0; L<=nLayers-1; L++){
		
			drn[L] 		= 0.0;
			swdelts[L]	= 0.0;		
		}
		
		excs 			= 0.0;
		tmpexcs			= 0.0;
		
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;			
			hold = (sl.SAT - swtemp[L]) * sl.Thickness;
			
			if(pinf > 0.001 && pinf > hold){
				
				if(L==0){
					drcm = 0.9 * swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}else{
					drcm = swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}
			
				drn[L] = pinf - hold + drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT * 24.0){					
					drn[L] 	= sl.KSAT * 24.0;
					drcm	= drn[L] + hold - pinf;
				}
				
				swtemp[L] = swtemp[L] + (pinf - drn[L])/sl.Thickness;
				
				if(swtemp[L] > sl.SAT){
					
					tmpexcs = (swtemp[L] - sl.SAT) * sl.Thickness;
					swtemp[L] = sl.SAT;
					
					if(L==0 && tmpexcs > 0.0){
						excs += tmpexcs;
					}
					
					if(L > 0){
						int Lup = L-1;
						
						while(tmpexcs > 0.0001 && Lup >=0){
							
							SoilLayer slup = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (Lup+1)));	
							hold = Math.min((slup.SAT - swtemp[Lup])*slup.Thickness,tmpexcs);
							swtemp[Lup] = swtemp[Lup] + hold / slup.Thickness;
							drn[Lup] = Math.max(drn[Lup] - tmpexcs,0);
							tmpexcs = tmpexcs - hold;
							
							if(Lup == 0 && tmpexcs > 0.0001){
							excs = excs + tmpexcs;
							}					
						}				
					}				
				}
				
				pinf = drn[L];
				
			}else{
			
			swtemp[L] = swtemp[L] + pinf / sl.Thickness;
			if(swtemp[L] >= sl.DUL + 0.003){
				
				if(L ==0){
					drcm = 0.9 * (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}else{
					drcm = (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}
				
				drn[L] = drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT*24.0){
					drn[L] = sl.KSAT*24.0;
					drcm = drn[L];				
				}
				
				swtemp[L] = swtemp[L] - drcm / sl.Thickness;
				pinf = drcm;
			
			}else{				
				pinf 	= 0.0;
				drn[L] 	= 0.0;			
			}			
			}
			
			swdelts[L] = swtemp[L] - sl.SWC;
			infilt = infilt + swdelts[L] * sl.Thickness * 10.;			
		}
		
		drain = pinf * 10.0;		
	}
	
	// Saturated flow calculations
	void SatFlow(){
		
		double drcm;
		double hold;
		double tmpexcs;
		double swold;
		double[] drn 		= new double[nLayers];
		double[] drmx		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		
		
		
		
		//double[] dlayr 	= new double[nLayers];
		//double[] dul	= new double[nLayers];
		//double[] sat	= new double[nLayers];
		
		println("HELLOOO");
		
				
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;
			drn[L] 		= 0.0;
			drmx[L]		= 0.0;
			swdelts[L]	= 0.0;
			
			if(swtemp[L] >= (sl.DUL + 0.003)){
				
				drmx[L] = Math.max(0,(swtemp[L] - sl.DUL) * swcon * sl.Thickness);
				
			}
			
			if(L == 0){
			
				drn[L] = drmx[L];
			}else{
			
				hold = 0.0;
				if(swtemp[L] < sl.DUL){
				hold = (sl.DUL - swtemp[L]) * sl.Thickness;
				}
				
				drn[L] = Math.max(0,drn[L-1] + drmx[L] - hold);
			}
			
			if(sl.KSAT > 0 && drn[L] > sl.KSAT*24.0){
			drn[L] = sl.KSAT * 24.0;
			}
			
			
			
		}//end of main loop
	
		for(int L = nLayers-1; L>=1; L--){
			
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swold = swtemp[L];
			swtemp[L] = swtemp[L] + (drn[L-1] - drn[L]) / sl.Thickness;
			if(swtemp[L] > sl.SAT){
			drn[L-1] = Math.max(0,(sl.SAT - swold) * sl.Thickness + drn[L]);
			swtemp[L] = sl.SAT;
			}		
		}
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
		swtemp[0] = swtemp[0] - drn[0] / sl.Thickness;
		drain = drn[nLayers-1] * 10;
		
		//Calculating the dwc/dt
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl_dt = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			swdelts[L] = swtemp[L] - sl_dt.SWC;
			sw_avail[L]	= Math.max(0., sl_dt.SWC + swdelts[L]);			
		
		}
	
	}
	
	
	void UpFlow(){
	
	int	ist;
	int M;
	double swold;
	double thet1;
	double thet2;
	double dbar;
	double grad;
	double flowfix;
	double[] upflow		= new double[nLayers];
	
	double[] swtemp		= new double[nLayers];
	double[] sw_inf		= new double[nLayers];	
	double[] esw		= new double[nLayers];
	
	for(int L = 0; L<=nLayers-1; L++){
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		
		upflow[L] = 0.0;
		swdeltu[L] = 0.0;
		swtemp[L] = sl.SWC;
		sw_inf[L] = sw_avail[L]; // sw_avail has been calculated previously on SatFlow method
		sw_avail[L] = Math.max(0., sw_avail[L] - sl.DUL);
		esw[L] = sl.DUL - sl.LL;	
	
	}
	
	SoilLayer top_sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (1)));
	
	if(top_sl.Thickness >= 5.0){ist=0;}else{ist=1;}
	
	for(int L = ist; L<=nLayers-2; L++){
		M = L + 1;
		swold = swtemp[L];
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		SoilLayer sl_M = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (M+1)));
		
		thet1 = Math.max(0,Math.min(swtemp[L] - sl.LL, esw[L]));
		thet2 = Math.max(0,Math.min(swtemp[M] - sl_M.LL, esw[M]));
		
		dbar = 0.88 * Math.exp(35.4 * ((thet1*sl.Thickness + thet2*sl_M.Thickness)/(sl.Thickness + sl_M.Thickness))* 0.5);
		dbar = Math.min(dbar,100.);
		
		grad = (thet2/esw[M] - thet1/esw[L]) * (esw[M] * sl_M.Thickness + esw[L] * sl.Thickness) / (sl_M.Thickness + sl.Thickness);
		
		upflow[L] = dbar * grad / ((sl.Thickness + sl_M.Thickness)*0.5);
		
		//upward flow from layer M to L
		
		if(upflow[L] > 0.){
		
			if(swtemp[L] <= sl.DUL){
			
				swtemp[L] = swtemp[L] + upflow[L] / sl.Thickness;
				sw_inf[L] = sw_inf[L] + upflow[L] / sl.Thickness;
				
				if(swtemp[L] > sl.DUL || sw_inf[L] > sl.SAT){
					
					flowfix = Math.max(0., ((swtemp[L] - sl.DUL) * sl.Thickness));
					flowfix = Math.max(flowfix, ((sw_inf[L] - sl.SAT) * sl.Thickness));
					flowfix = Math.min(upflow[L], flowfix);
					upflow[L] = upflow[L] - flowfix;
					swtemp[L] = swold + upflow[L] / sl.Thickness;		
				
				}
			
			}else{				
				upflow[L] = 0.;							
			}
			
			if(upflow[L] / sl.Thickness > sw_avail[M]){
			
				upflow[L] = sw_avail[M] * sl_M.Thickness;
				swtemp[L] = swold + upflow[L] / sl.Thickness;
			
			}
			
			swtemp[M] = swtemp[M] - upflow[L] / sl_M.Thickness;
		
		//downward flow from layer L to M
		}else if(upflow[L] < 0.){
			
			if(swtemp[L] >= sl.LL){
			
				if(Math.abs(upflow[L] / sl.Thickness) > sw_avail[L]){
				
					upflow[L] = -sw_avail[L] * sl.Thickness;
				
				}
				
				swtemp[L] = swtemp[L] + upflow[L] / sl.Thickness;
				swtemp[M] = swtemp[M] - upflow[L] / sl_M.Thickness;
				sw_inf[M] = sw_inf[M] - upflow[L] / sl_M.Thickness;
				
				if(sw_inf[M] > sl_M.SAT){
					
					flowfix = Math.min(Math.abs(upflow[L]), (sw_inf[M] - sl_M.SAT) * sl_M.Thickness);
					upflow[L] = upflow[L] + flowfix;
					swtemp[L] = swold + upflow[L] / sl.Thickness;
					swtemp[M] = swtemp[M] - flowfix / sl_M.Thickness;
				
				}
			
				// no downwar movement if swtemp < LL
			}else{
			
				upflow[L] = 0.;
			
			}
		
		}
		
	
	}//end of main loop
	
	
	for(int L = 0; L<=nLayers-1; L++){		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		swdeltu[L] = swtemp[L] - sl.SWC;	
		}	
	}
	
	void wbsum(){		
		
		tsw = sum((* sl:SoilLayer, (sl.row == row && sl.strip == strip) *)[TSWC]);
		crain += rain;
		tdrain += drain;
		trunof += runoff;
		
		
		// sum of initial conditions
		if(dayOfYear == (startingDayOfYear+1) && year == (startingyear)){
		
			crain 	= 0.;
			tdrain	= 0.;
			trunof	= 0.;
			tswini	= 0.;
			
			tswini = sum((* sl:SoilLayer, (sl.row == row && sl.strip == strip) *)[SWC]);
			tsw = tswini;		
		
		}	
	
	}
	
	void wtdept(){
		
		double tol = 0.95;
		
		
	for(int L = nLayers-1; L>=0; L--){
		
		SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
		
		satfrac[L] = (sl.SWC - sl.DUL) / (sl.SAT - sl.DUL);
		satfrac[L] = Math.min(Math.max(0.0, satfrac[L]), 1.0);
		

	}
	
	}
	
	
	void DailyIntegration(){
	
		
		for(int L = 0; L<=nLayers-1; L++){
			
			
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			sw_mm[L] 		= sl.SWC 		* sl.Thickness * 10.;
			swdelts_mm[L]	= swdelts[L] 	* sl.Thickness * 10.; 
			swdeltx_mm[L]	= swdelts[L] 	* sl.Thickness * 10.;
			swdeltl_mm[L]	= swdelts[L] 	* sl.Thickness * 10.;
			swdeltu_mm[L]	= swdelts[L] 	* sl.Thickness * 10.;
			swdeltt_mm[L]	= swdelts[L] 	* sl.Thickness * 10.;
			
			
			sw_mm_NEW[L] = sw_mm[L] + swdelts_mm[L] + swdeltu_mm[L] + swdeltl_mm[L] + swdeltx_mm[L] + swdeltt_mm[L];
				
			sl.SWC = sw_mm_NEW[L] / sl.Thickness / 10.;
			sl.TSWC = sl.SWC * sl.Thickness;
			
		}	
		
	
	}

	void WaterBalance(){
		
		double swdeltu;
		double swdeltt;
		double swdeltl;
		
	
		// -----------------------
		// Daily rate calculations
		// -----------------------
		
		
		
		//check whether snow is happening
		if(tmax <= 1 && snow > 0.001){		
			// compute snow contribution to water income
		}else{
		watavl = rain;
		}
		
		
		//check if all rate variables are set to zero here... <<<<<<<<
		
		//condition when the field is pudded
		if(puddled){
		//compute conditions for puddled fields...
		
		}else{
			
		//non-puddled, flooded or non-flooded field		
		pinf 	= 0.;
		winf	= 0.;
		infilt	= 0.;
		
		// Bunded field (rice)?
		if(bunded){		
			runoff = 0.;
			winf = Math.max(0, flood + irrig + rain); //(mm)					
		}else{
		// Upland field
		// Not bunded, flooded conditions not possible (this is not Holland)
		
		//water first absorbed by mulch, if presents
		if(mulchEffect){
		//Ritchie mulch effect model
		}
		
		
		
		// Compute runoff
		Runoff();		
		winf = watavl - runoff + irrig; //(mm)	
		
		}
		
		
		
		// potential for infiltration
		pinf = winf * 0.1;				//(cm)
		
		//call infiltration() method to calculate infiltration rates on days with irrigation or rainfall.
		//call SatFlow() method on days with no irrigation or rain to calulate satirated flow.		
		if(pinf > 0.0001){	
			
			// calculating the amount of water for intiltration (infilt, drain, drn, excs, swdelts)
			infilt = 0.0;
			Infiltration();			
			infilt = infilt + drain;
						
			//Excess water not infiltrated is added to overland runoff
			//if bunded, excess water is accounted for in infilt variable
			if(excs > 0 && bunded == false){
			runoff = runoff + excs * 10.0;
			}		
		}else{
			
			SatFlow();
			println("HELLOOO");
		}
		
		if(tdlno > 0){
		//tiledrain computation...
		}
		
		}
		
		
		if(flood <= 0.0){			
			UpFlow();		
		}
		
		// to be constructed to account for tillage effect on swc
		//if(tillage){}
		
		
		// -----------------------
		// Daily integration
		// -----------------------
		
		//perform integration of soil water fluxes
		// substract soil evaporation from layer 1
		
		DailyIntegration();
		
		
		
	}//end of method
	
	
	
	void initiate(int TileRow, int TileStrip){
		
		row 	= TileRow;
		strip 	= TileStrip;
		cn		= cn_runoff;
		swcon	= swcon_runoff;
		nLayers	= Layer_Depth.length;
		tdlno	= 0;
		pinf	= 0.;
		winf	= 0.;
		infilt	= 0.;
		watavl	= 0.;
		drain	= 0.;
		flood	= 0.; // no flood <--- should be at parameters
		
		//Flag conditions
		puddled			= false;
		bunded			= false;
		mulchEffect		= false;
	}

	
	
}