import static parameters.*;
import static environment.*;
import static modules_base.*;
import static modules_light.*;

import de.grogra.ray.physics.Spectrum;
import de.grogra.ray.physics.Spectrum3d;

// soil profile associated to an individual plant
module SoilLayer
{
	int    row;
	int	   strip;
	int    rank;
	double upper;
	double bottom;
	double LL;
	double DUL;
	double SAT;
	double KSAT;
	double BDEN;
	double SLOC;
	double Thickness;
	double PlantDist;
	double RowDist;
	double Depth;
	double SWC;
	
	void initialConditions(){
	
		SWC = DUL;
	}
	
	
	void infil(){
	}
	
	void satflow(){
	}
	
	void upflow(){
	}
	

	// initiation of a soil layer
	void initiate(int nLayer, int TileRow, int TileStrip)
	{
		rank 	= nLayer;
		row  	= TileRow;
		strip 	= TileStrip;
		Depth 	= Layer_Depth[nLayer-1];
		LL 		= Layer_LL[nLayer-1];
		DUL 	= Layer_DUL[nLayer-1];
		SAT		= Layer_SAT[nLayer-1];
		KSAT	= Layer_KSAT[nLayer-1];
		BDEN	= Layer_BDEN[nLayer-1];
		SLOC	= Layer_SLOC[nLayer-1];
		
		Thickness = (nLayer == 1 ? Layer_Depth[nLayer-1]:(Layer_Depth[nLayer-1] - Layer_Depth[nLayer-2]));
		upper = Depth - Thickness;
		bottom = Depth;
		
		PlantDist = 0.25;
		RowDist = 1.4;
		
		if(nLayer == 1) {Depth = Depth + 0.001;}
		
		
	}
} 
==> 
Translate(0,0,-Depth) Box(Thickness,PlantDist,RowDist).(setColor(0.51,0.33,0.16))
;

module SoilProfile() extends Null{
	
	int		row;
	int		strip;
	int		cn;
	int		nLayers;
	double	swcon;
	double 	runoff;
	double	watavl;
	double  winf;		//Water available for infiltration - rainfall minus runoff plus  net irrigation (mm / d)
	double  pinf;
	
	// Run-off calculations
	void runoff(int cn, double watavl, boolean mulchEffect, double mulch){
		
		//cn = curve number - measure of runoff potential based on soil type and current soil water content. 
		//watavl = rain + irrigation;
		
		double swabi;			// A soil water abstraction index, a unitless indicator of the soil water condition at the time of a rainfall event.  This affects the intercept of the runoff axis when runoff starts to occur--later when drier and sooner when wetter.
		double iabs;			// Initial abstraction ratio, modified for surface mulch layer effects.
		double maxiabs = 0.6;	// Maximum initial abstraction ratio
		double smx;				// Soil storage available for surface water based on CN formula	(mm)
		double pb;				// Determines threshold amount of rainfall that will occur before runoff starts (mm/d)
		
		smx = 254.0 * (100.0/cn - 1.0);
		
		// Uses only two firsts layers to compute runoff
		SoilLayer sl1 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 1));
		SoilLayer sl2 = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == 2));
		
		swabi = Math.max(0, 0.15 * ((sl1.SAT - sl1.SWC)/(sl1.SAT - sl1.LL * 0.5) + (sl2.SAT - sl2.SWC)/(sl2.SAT - sl2.LL * 0.5)));
		
		if(mulchEffect){
		iabs = swabi + (maxiabs - swabi) * mulch;
		}else{
		iabs = swabi;
		}
		
		pb = watavl - iabs * smx;
		
		if(watavl > 0.001){
			if(pb > 0){
				runoff	= pb**2/(watavl + (1-iabs) * smx);
			}else{
				runoff	= 0.0;
			}		
		}else{		
			runoff = 0.0;
		}		
		
	}
	
	
	void infiltration(){
		
		
		double drain;
		double drcm;
		double excs;
		double hold;
		double tmpexcs;
		double[] drn 		= new double[nLayers];
		double[] swtemp		= new double[nLayers];
		double[] swdelts	= new double[nLayers];
		
		//double[] dlayr 	= new double[nLayers];
		//double[] dul	= new double[nLayers];
		//double[] sat	= new double[nLayers];
		
		for(int L = 0; L<=nLayers-1; L++){
		
			drn[L] 		= 0.0;
			swdelts[L]	= 0.0;		
		}
		
		excs 			= 0.0;
		tmpexcs			= 0.0;
		
		for(int L = 0; L<=nLayers-1; L++){
		
			SoilLayer sl = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (L+1)));
			
			swtemp[L]	= sl.SWC;			
			hold = (sl.SAT - swtemp[L]) * sl.Thickness;
			
			if(pinf > 0.001 && pinf > hold){
				
				if(L==0){
					drcm = 0.9 * swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}else{
					drcm = swcon * (sl.SAT - sl.DUL) * sl.Thickness;
				}
			
				drn[L] = pinf - hold + drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT * 24.0){					
					drn[L] 	= sl.KSAT * 24.0;
					drcm	= drn[L] + hold - pinf;
				}
				
				swtemp[L] = swtemp[L] + (pinf - drn[L])/sl.Thickness;
				
				if(swtemp[L] > sl.SAT){
					
					tmpexcs = (swtemp[L] - sl.SAT) * sl.Thickness;
					swtemp[L] = sl.SAT;
					
					if(L==0 && tmpexcs > 0.0){
						excs += tmpexcs;
					}
					
					if(L > 0){
						int Lup = L-1;
						
						while(tmpexcs > 0.0001 && Lup >=0){
							
							SoilLayer slup = selectWhere((*s:SoilLayer*), (s.row == row && s.strip == strip && s.rank == (Lup+1)));	
							hold = Math.min((slup.SAT - swtemp[Lup])*slup.Thickness,tmpexcs);
							swtemp[Lup] = swtemp[Lup] + hold / slup.Thickness;
							drn[Lup] = Math.max(drn[Lup] - tmpexcs,0);
							tmpexcs = tmpexcs - hold;
							
							if(Lup == 0 && tmpexcs > 0.0001){
							excs = excs + tmpexcs;
							}					
						}				
					}				
				}
				
				pinf = drn[L];
				
			}else{
			
			swtemp[L] = swtemp[L] + pinf / sl.Thickness;
			if(swtemp[L] >= sl.DUL + 0.003){
				
				if(L ==0){
					drcm = 0.9 * (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}else{
					drcm = (swtemp[L] - sl.DUL) * swcon * sl.Thickness;
				}
				
				drn[L] = drcm;
				
				if(sl.KSAT > 0.0 && drn[L] > sl.KSAT*24.0){
					drn[L] = sl.KSAT*24.0;
					drcm = drn[L];				
				}
				
				swtemp[L] = swtemp[L] - drcm / sl.Thickness;
				pinf = drcm;
			
			}else{				
				pinf 	= 0.0;
				drn[L] 	= 0.0;			
			}			
			}
			
			swdelts[L] = swtemp[L] - sl.SWC;			
		}
		
		drain = pinf * 10.0;		
	}

	void WaterBalance(){
		
		
		
		// call runoff first of getting here
		winf = watavl - runoff + irrig; //(mm)
		pinf = winf * 0.1;				//(cm)
		
		
	}
	
	
	
	void initiate(int TileRow, int TileStrip){
		
		row 	= TileRow;
		strip 	= TileStrip;
		cn		= cn_runoff;
		swcon	=
		nLayers	= Layer_Depth.length;
	
	}

	
	
}